using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NetTopologySuite.IO;
using TRRCMS.Application.Common.Interfaces;
using TRRCMS.Application.Import.Dtos;
using TRRCMS.Application.Import.Models;
using TRRCMS.Domain.Entities;
using TRRCMS.Domain.Entities.Staging;
using TRRCMS.Domain.Enums;

namespace TRRCMS.Infrastructure.Services;

/// <summary>
/// Implements <see cref="ICommitService"/> — commits approved staging data to production.
///
/// Commit order matters due to FK dependencies:
///   1. Buildings       (no FK dependencies)
///   2. PropertyUnits   (FK → Buildings)
///   3. Persons         (no FK dependencies)
///   4. Households      (FK → PropertyUnits, optional FK → Persons)
///   5. PersonPropertyRelations (FK → Persons, FK → PropertyUnits)
///   6. Surveys         (FK → Buildings, FK → PropertyUnits)
///   7. Claims          (FK → PropertyUnits, optional FK → Persons)
///   8. Evidence        (FK → Persons, FK → PersonPropertyRelations, FK → Claims)
///
/// Each step uses a mapping dictionary (OriginalEntityId → ProductionId) to resolve
/// cross-references from the .uhc package to production FKs.
///
/// Record IDs per FSD Section 7:
///   - Buildings: 17-digit geographic ID (GG-DD-SS-CCC-NNN-BBBBB) — composed by Building.Create()
///   - PropertyUnits: Building ID + 3-digit unit number — composed by PropertyUnit.Create()
///   - Claims: CL-YYYY-NNNNNN — generated by IClaimNumberGenerator
///   - Other entities (Persons, Households, Relations, Evidence, Surveys): UUID only, no Record ID.
///
/// FSD: FR-D-8 (Record ID Generation), FR-D-9 (Attachment Deduplication).
/// UC-003 Stage 4 — S17 (Commit to Production).
/// </summary>
public class CommitService : ICommitService
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly IStagingRepository<StagingBuilding> _stagingBuildingRepo;
    private readonly IStagingRepository<StagingPropertyUnit> _stagingPropertyUnitRepo;
    private readonly IStagingRepository<StagingPerson> _stagingPersonRepo;
    private readonly IStagingRepository<StagingHousehold> _stagingHouseholdRepo;
    private readonly IStagingRepository<StagingPersonPropertyRelation> _stagingRelationRepo;
    private readonly IStagingRepository<StagingEvidence> _stagingEvidenceRepo;
    private readonly IStagingRepository<StagingClaim> _stagingClaimRepo;
    private readonly IStagingRepository<StagingSurvey> _stagingSurveyRepo;
    private readonly IImportPackageRepository _importPackageRepository;
    private readonly IClaimNumberGenerator _claimNumberGenerator;
    private readonly IImportService _importService;
    private readonly IFileStorageService _fileStorageService;
    private readonly ImportPipelineSettings _settings;
    private readonly ILogger<CommitService> _logger;

    // ID mapping: OriginalEntityId (from .uhc) → Production Entity Id
    private readonly Dictionary<Guid, Guid> _idMap = new();

    public CommitService(
        IUnitOfWork unitOfWork,
        IStagingRepository<StagingBuilding> stagingBuildingRepo,
        IStagingRepository<StagingPropertyUnit> stagingPropertyUnitRepo,
        IStagingRepository<StagingPerson> stagingPersonRepo,
        IStagingRepository<StagingHousehold> stagingHouseholdRepo,
        IStagingRepository<StagingPersonPropertyRelation> stagingRelationRepo,
        IStagingRepository<StagingEvidence> stagingEvidenceRepo,
        IStagingRepository<StagingClaim> stagingClaimRepo,
        IStagingRepository<StagingSurvey> stagingSurveyRepo,
        IImportPackageRepository importPackageRepository,
        IClaimNumberGenerator claimNumberGenerator,
        IImportService importService,
        IFileStorageService fileStorageService,
        IOptions<ImportPipelineSettings> settings,
        ILogger<CommitService> logger)
    {
        _unitOfWork = unitOfWork;
        _stagingBuildingRepo = stagingBuildingRepo;
        _stagingPropertyUnitRepo = stagingPropertyUnitRepo;
        _stagingPersonRepo = stagingPersonRepo;
        _stagingHouseholdRepo = stagingHouseholdRepo;
        _stagingRelationRepo = stagingRelationRepo;
        _stagingEvidenceRepo = stagingEvidenceRepo;
        _stagingClaimRepo = stagingClaimRepo;
        _stagingSurveyRepo = stagingSurveyRepo;
        _importPackageRepository = importPackageRepository;
        _claimNumberGenerator = claimNumberGenerator;
        _importService = importService;
        _fileStorageService = fileStorageService;
        _settings = settings.Value;
        _logger = logger;
    }

    /// <inheritdoc />
    public async Task<CommitReportDto> CommitAsync(
        Guid importPackageId,
        Guid committedByUserId,
        CancellationToken cancellationToken = default)
    {
        _idMap.Clear();

        var report = new CommitReportDto
        {
            ImportPackageId = importPackageId,
            CommittedByUserId = committedByUserId,
            CommittedAtUtc = DateTime.UtcNow
        };

        var package = await _importPackageRepository.GetByIdAsync(importPackageId, cancellationToken)
            ?? throw new InvalidOperationException($"Package {importPackageId} not found.");

        report.PackageNumber = package.PackageNumber;

        // Execute the entire commit in a transaction
        await _unitOfWork.ExecuteInTransactionAsync(async () =>
        {
            // Commit in FK-dependency order
            await CommitBuildingsAsync(importPackageId, committedByUserId, report, cancellationToken);
            await CommitPropertyUnitsAsync(importPackageId, committedByUserId, report, cancellationToken);
            await CommitPersonsAsync(importPackageId, committedByUserId, report, cancellationToken);
            await CommitHouseholdsAsync(importPackageId, committedByUserId, report, cancellationToken);
            await CommitPersonPropertyRelationsAsync(importPackageId, committedByUserId, report, cancellationToken);
            await CommitSurveysAsync(importPackageId, committedByUserId, report, cancellationToken);
            await CommitClaimsAsync(importPackageId, committedByUserId, report, cancellationToken);
            await CommitEvidenceAsync(importPackageId, committedByUserId, report, cancellationToken);
        }, cancellationToken);

        // Update aggregate counts
        report.TotalRecordsCommitted =
            report.Buildings.Committed + report.PropertyUnits.Committed +
            report.Persons.Committed + report.Households.Committed +
            report.PersonPropertyRelations.Committed + report.Evidences.Committed +
            report.Claims.Committed + report.Surveys.Committed;

        report.TotalRecordsFailed =
            report.Buildings.Failed + report.PropertyUnits.Failed +
            report.Persons.Failed + report.Households.Failed +
            report.PersonPropertyRelations.Failed + report.Evidences.Failed +
            report.Claims.Failed + report.Surveys.Failed;

        report.TotalRecordsApproved =
            report.Buildings.Approved + report.PropertyUnits.Approved +
            report.Persons.Approved + report.Households.Approved +
            report.PersonPropertyRelations.Approved + report.Evidences.Approved +
            report.Claims.Approved + report.Surveys.Approved;

        report.Status = report.IsFullySuccessful
            ? ImportStatus.Completed.ToString()
            : (report.TotalRecordsCommitted > 0 ? ImportStatus.PartiallyCompleted.ToString() : ImportStatus.Failed.ToString());

        return report;
    }

    /// <inheritdoc />
    public async Task<string> ArchivePackageAsync(
        Guid importPackageId,
        Guid committedByUserId,
        CancellationToken cancellationToken = default)
    {
        var package = await _importPackageRepository.GetByIdAsync(importPackageId, cancellationToken)
            ?? throw new InvalidOperationException($"Package {importPackageId} not found.");

        // Build source path from package storage location
        var sourceFilePath = Path.Combine(_settings.PackageStoragePath, package.FileName);

        if (!File.Exists(sourceFilePath))
        {
            _logger.LogWarning("Source .uhc file not found at {Path}, skipping archive.", sourceFilePath);
            return string.Empty;
        }

        var archivePath = await _importService.ArchivePackageAsync(
            sourceFilePath, package.PackageId, cancellationToken);

        return archivePath;
    }

    // ==================== ENTITY-SPECIFIC COMMIT METHODS ====================

    /// <summary>
    /// Commit buildings to production.
    /// Building Record ID (BuildingId) is a 17-digit geographic hierarchy code
    /// composed automatically by Building.Create() from the administrative codes
    /// (GovernorateCode + DistrictCode + SubDistrictCode + CommunityCode +
    /// NeighborhoodCode + BuildingNumber). No external sequence needed.
    /// FSD Section 7: Building Record ID format GG-DD-SS-CCC-NNN-BBBBB.
    /// </summary>
    private async Task CommitBuildingsAsync(
        Guid importPackageId, Guid userId, CommitReportDto report, CancellationToken ct)
    {
        var approved = await _stagingBuildingRepo.GetApprovedForCommitAsync(importPackageId, ct);
        report.Buildings.EntityType = "Building";
        report.Buildings.Approved = approved.Count;

        if (approved.Count == 0) return;

        for (var i = 0; i < approved.Count; i++)
        {
            var staging = approved[i];
            try
            {
                // Building.Create() composes the 17-digit BuildingId from geographic codes (FR-D-8)
                var building = Building.Create(
                    governorateCode: staging.GovernorateCode,
                    districtCode: staging.DistrictCode,
                    subDistrictCode: staging.SubDistrictCode,
                    communityCode: staging.CommunityCode,
                    neighborhoodCode: staging.NeighborhoodCode,
                    buildingNumber: staging.BuildingNumber,
                    governorateName: staging.GovernorateName ?? string.Empty,
                    districtName: staging.DistrictName ?? string.Empty,
                    subDistrictName: staging.SubDistrictName ?? string.Empty,
                    communityName: staging.CommunityName ?? string.Empty,
                    neighborhoodName: staging.NeighborhoodName ?? string.Empty,
                    buildingType: staging.BuildingType,
                    status: staging.Status,
                    createdByUserId: userId);

                building.UpdateUnitCounts(
                    staging.NumberOfPropertyUnits,
                    staging.NumberOfApartments,
                    staging.NumberOfShops,
                    userId);

                building.UpdateDetails(
                    staging.NumberOfFloors,
                    staging.YearOfConstruction,
                    staging.Address,
                    staging.Landmark,
                    staging.LocationDescription,
                    staging.Notes,
                    userId);

                if (staging.BuildingGeometryWkt != null)
                    building.SetGeometry(staging.BuildingGeometryWkt, userId);

                if (staging.Latitude.HasValue && staging.Longitude.HasValue)
                    building.SetCoordinates(staging.Latitude.Value, staging.Longitude.Value, userId);

                if (staging.DamageLevel.HasValue)
                    building.UpdateStatus(staging.Status, staging.DamageLevel, userId);

                await _unitOfWork.Buildings.AddAsync(building, ct);

                _idMap[staging.OriginalEntityId] = building.Id;
                staging.SetCommittedEntityId(building.Id);
                await _stagingBuildingRepo.UpdateAsync(staging, ct);

                report.Buildings.Committed++;
                report.Buildings.IdMappings[staging.OriginalEntityId] = building.Id;

                _logger.LogDebug(
                    "Committed Building {OriginalId} → {ProductionId} (BuildingId: {BuildingId})",
                    staging.OriginalEntityId, building.Id, building.BuildingId);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to commit Building {OriginalId}", staging.OriginalEntityId);
                report.Buildings.Failed++;
                report.Errors.Add(new CommitErrorDto
                {
                    EntityType = "Building",
                    StagingEntityId = staging.Id,
                    OriginalEntityId = staging.OriginalEntityId,
                    ErrorMessage = ex.Message
                });
            }
        }
    }

    /// <summary>
    /// Commit property units to production.
    /// Property Unit ID is derived from parent Building ID + UnitIdentifier.
    /// FSD Section 7: Full format = BuildingId-UnitNumber (e.g. 01-01-02-003-001-00001-001).
    /// </summary>
    private async Task CommitPropertyUnitsAsync(
        Guid importPackageId, Guid userId, CommitReportDto report, CancellationToken ct)
    {
        var approved = await _stagingPropertyUnitRepo.GetApprovedForCommitAsync(importPackageId, ct);
        report.PropertyUnits.EntityType = "PropertyUnit";
        report.PropertyUnits.Approved = approved.Count;

        if (approved.Count == 0) return;

        for (var i = 0; i < approved.Count; i++)
        {
            var staging = approved[i];
            try
            {
                // Resolve parent building FK
                if (!_idMap.TryGetValue(staging.OriginalBuildingId, out var productionBuildingId))
                {
                    throw new InvalidOperationException(
                        $"Parent Building {staging.OriginalBuildingId} not found in ID map. " +
                        "Building must be committed before its property units.");
                }

                var unit = PropertyUnit.Create(
                    buildingId: productionBuildingId,
                    unitIdentifier: staging.UnitIdentifier,
                    unitType: staging.UnitType,
                    floorNumber: staging.FloorNumber,
                    createdByUserId: userId);

                await _unitOfWork.PropertyUnits.AddAsync(unit, ct);

                _idMap[staging.OriginalEntityId] = unit.Id;
                staging.SetCommittedEntityId(unit.Id);
                await _stagingPropertyUnitRepo.UpdateAsync(staging, ct);

                report.PropertyUnits.Committed++;
                report.PropertyUnits.IdMappings[staging.OriginalEntityId] = unit.Id;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to commit PropertyUnit {OriginalId}", staging.OriginalEntityId);
                report.PropertyUnits.Failed++;
                report.Errors.Add(new CommitErrorDto
                {
                    EntityType = "PropertyUnit",
                    StagingEntityId = staging.Id,
                    OriginalEntityId = staging.OriginalEntityId,
                    ErrorMessage = ex.Message
                });
            }
        }
    }

    private async Task CommitPersonsAsync(
        Guid importPackageId, Guid userId, CommitReportDto report, CancellationToken ct)
    {
        var approved = await _stagingPersonRepo.GetApprovedForCommitAsync(importPackageId, ct);
        report.Persons.EntityType = "Person";
        report.Persons.Approved = approved.Count;

        if (approved.Count == 0) return;

        for (var i = 0; i < approved.Count; i++)
        {
            var staging = approved[i];
            try
            {
                var person = Person.CreateWithFullInfo(
                    familyNameArabic: staging.FamilyNameArabic,
                    firstNameArabic: staging.FirstNameArabic,
                    fatherNameArabic: staging.FatherNameArabic,
                    motherNameArabic: staging.MotherNameArabic,
                    nationalId: staging.NationalId,
                    dateOfBirth: staging.YearOfBirth.HasValue ? new DateTime(staging.YearOfBirth.Value, 1, 1, 0, 0, 0, DateTimeKind.Utc) : null,
                    gender: null, // TODO: Add to staging entity
                    nationality: null, // TODO: Add to staging entity
                    email: staging.Email,
                    mobileNumber: staging.MobileNumber,
                    phoneNumber: staging.PhoneNumber,
                    createdByUserId: userId);

                await _unitOfWork.Persons.AddAsync(person, ct);

                _idMap[staging.OriginalEntityId] = person.Id;
                staging.SetCommittedEntityId(person.Id);
                await _stagingPersonRepo.UpdateAsync(staging, ct);

                report.Persons.Committed++;
                report.Persons.IdMappings[staging.OriginalEntityId] = person.Id;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to commit Person {OriginalId}", staging.OriginalEntityId);
                report.Persons.Failed++;
                report.Errors.Add(new CommitErrorDto
                {
                    EntityType = "Person",
                    StagingEntityId = staging.Id,
                    OriginalEntityId = staging.OriginalEntityId,
                    ErrorMessage = ex.Message
                });
            }
        }
    }

    private async Task CommitHouseholdsAsync(
        Guid importPackageId, Guid userId, CommitReportDto report, CancellationToken ct)
    {
        var approved = await _stagingHouseholdRepo.GetApprovedForCommitAsync(importPackageId, ct);
        report.Households.EntityType = "Household";
        report.Households.Approved = approved.Count;

        if (approved.Count == 0) return;

        for (var i = 0; i < approved.Count; i++)
        {
            var staging = approved[i];
            try
            {
                if (!_idMap.TryGetValue(staging.OriginalPropertyUnitId, out var productionUnitId))
                {
                    throw new InvalidOperationException(
                        $"Parent PropertyUnit {staging.OriginalPropertyUnitId} not found in ID map.");
                }

                var household = Household.Create(
                    propertyUnitId: productionUnitId,
                    headOfHouseholdName: staging.HeadOfHouseholdName,
                    householdSize: staging.HouseholdSize,
                    maleCount: staging.MaleCount,
                    femaleCount: staging.FemaleCount,
                    maleChildCount: staging.MaleChildCount,
                    femaleChildCount: staging.FemaleChildCount,
                    maleElderlyCount: staging.MaleElderlyCount,
                    femaleElderlyCount: staging.FemaleElderlyCount,
                    maleDisabledCount: staging.MaleDisabledCount,
                    femaleDisabledCount: staging.FemaleDisabledCount,
                    notes: null,
                    occupancyType: null, // Not captured during import
                    occupancyNature: null, // Not captured during import
                    createdByUserId: userId);

                await _unitOfWork.Households.AddAsync(household, ct);

                _idMap[staging.OriginalEntityId] = household.Id;
                staging.SetCommittedEntityId(household.Id);
                await _stagingHouseholdRepo.UpdateAsync(staging, ct);

                report.Households.Committed++;
                report.Households.IdMappings[staging.OriginalEntityId] = household.Id;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to commit Household {OriginalId}", staging.OriginalEntityId);
                report.Households.Failed++;
                report.Errors.Add(new CommitErrorDto
                {
                    EntityType = "Household",
                    StagingEntityId = staging.Id,
                    OriginalEntityId = staging.OriginalEntityId,
                    ErrorMessage = ex.Message
                });
            }
        }
    }

    private async Task CommitPersonPropertyRelationsAsync(
        Guid importPackageId, Guid userId, CommitReportDto report, CancellationToken ct)
    {
        var approved = await _stagingRelationRepo.GetApprovedForCommitAsync(importPackageId, ct);
        report.PersonPropertyRelations.EntityType = "PersonPropertyRelation";
        report.PersonPropertyRelations.Approved = approved.Count;

        if (approved.Count == 0) return;

        for (var i = 0; i < approved.Count; i++)
        {
            var staging = approved[i];
            try
            {
                if (!_idMap.TryGetValue(staging.OriginalPersonId, out var productionPersonId))
                    throw new InvalidOperationException(
                        $"Person {staging.OriginalPersonId} not found in ID map.");

                if (!_idMap.TryGetValue(staging.OriginalPropertyUnitId, out var productionUnitId))
                    throw new InvalidOperationException(
                        $"PropertyUnit {staging.OriginalPropertyUnitId} not found in ID map.");

                var relation = PersonPropertyRelation.Create(
                    personId: productionPersonId,
                    propertyUnitId: productionUnitId,
                    relationType: staging.RelationType,
                    occupancyType: null, // Not captured during import
                    hasEvidence: false, // Not captured during import
                    createdByUserId: userId);

                relation.UpdateRelationDetails(
                    relationType: staging.RelationType,
                    occupancyType: null, // Not captured during import
                    hasEvidence: false, // Not captured during import
                    ownershipShare: staging.OwnershipShare,
                    contractDetails: staging.ContractDetails,
                    notes: staging.Notes,
                    modifiedByUserId: userId);

                await _unitOfWork.PersonPropertyRelations.AddAsync(relation, ct);

                _idMap[staging.OriginalEntityId] = relation.Id;
                staging.SetCommittedEntityId(relation.Id);
                await _stagingRelationRepo.UpdateAsync(staging, ct);

                report.PersonPropertyRelations.Committed++;
                report.PersonPropertyRelations.IdMappings[staging.OriginalEntityId] = relation.Id;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to commit PersonPropertyRelation {OriginalId}", staging.OriginalEntityId);
                report.PersonPropertyRelations.Failed++;
                report.Errors.Add(new CommitErrorDto
                {
                    EntityType = "PersonPropertyRelation",
                    StagingEntityId = staging.Id,
                    OriginalEntityId = staging.OriginalEntityId,
                    ErrorMessage = ex.Message
                });
            }
        }
    }

    private async Task CommitSurveysAsync(
        Guid importPackageId, Guid userId, CommitReportDto report, CancellationToken ct)
    {
        var approved = await _stagingSurveyRepo.GetApprovedForCommitAsync(importPackageId, ct);
        report.Surveys.EntityType = "Survey";
        report.Surveys.Approved = approved.Count;

        if (approved.Count == 0) return;

        for (var i = 0; i < approved.Count; i++)
        {
            var staging = approved[i];
            try
            {
                if (!_idMap.TryGetValue(staging.OriginalBuildingId, out var productionBuildingId))
                    throw new InvalidOperationException(
                        $"Building {staging.OriginalBuildingId} not found in ID map.");

                Guid? productionPropertyUnitId = null;
                if (staging.OriginalPropertyUnitId.HasValue &&
                    _idMap.TryGetValue(staging.OriginalPropertyUnitId.Value, out var unitId))
                {
                    productionPropertyUnitId = unitId;
                }

                // Resolve field collector ID — use the import user if original not found
                var fieldCollectorId = userId;
                if (staging.OriginalFieldCollectorId.HasValue)
                {
                    // OriginalFieldCollectorId is a User ID, not a staging entity — use directly
                    fieldCollectorId = staging.OriginalFieldCollectorId.Value;
                }

                var surveyType = staging.Type?.ToString() ?? "Field";
                var survey = Survey.Create(
                    buildingId: productionBuildingId,
                    fieldCollectorId: fieldCollectorId,
                    surveyType: surveyType,
                    surveyDate: staging.SurveyDate,
                    propertyUnitId: productionPropertyUnitId,
                    createdByUserId: userId);

                await _unitOfWork.Surveys.AddAsync(survey, ct);

                _idMap[staging.OriginalEntityId] = survey.Id;
                staging.SetCommittedEntityId(survey.Id);
                await _stagingSurveyRepo.UpdateAsync(staging, ct);

                report.Surveys.Committed++;
                report.Surveys.IdMappings[staging.OriginalEntityId] = survey.Id;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to commit Survey {OriginalId}", staging.OriginalEntityId);
                report.Surveys.Failed++;
                report.Errors.Add(new CommitErrorDto
                {
                    EntityType = "Survey",
                    StagingEntityId = staging.Id,
                    OriginalEntityId = staging.OriginalEntityId,
                    ErrorMessage = ex.Message
                });
            }
        }
    }

    /// <summary>
    /// Commit claims to production with Claim Number generation (CL-YYYY-NNNNNN).
    /// FSD Section 7: Claim ID format CL-YYYY-NNNNNN via IClaimNumberGenerator.
    /// </summary>
    private async Task CommitClaimsAsync(
        Guid importPackageId, Guid userId, CommitReportDto report, CancellationToken ct)
    {
        var approved = await _stagingClaimRepo.GetApprovedForCommitAsync(importPackageId, ct);
        report.Claims.EntityType = "Claim";
        report.Claims.Approved = approved.Count;

        if (approved.Count == 0) return;

        for (var i = 0; i < approved.Count; i++)
        {
            var staging = approved[i];
            try
            {
                if (!_idMap.TryGetValue(staging.OriginalPropertyUnitId, out var productionUnitId))
                    throw new InvalidOperationException(
                        $"PropertyUnit {staging.OriginalPropertyUnitId} not found in ID map.");

                Guid? productionClaimantId = null;
                if (staging.OriginalPrimaryClaimantId.HasValue &&
                    _idMap.TryGetValue(staging.OriginalPrimaryClaimantId.Value, out var claimantId))
                {
                    productionClaimantId = claimantId;
                }

                // Generate a proper claim number via the existing generator (FR-D-8)
                var claimNumber = await _claimNumberGenerator.GenerateNextClaimNumberAsync(ct);

                var claim = Claim.Create(
                    claimNumber: claimNumber,
                    propertyUnitId: productionUnitId,
                    primaryClaimantId: productionClaimantId,
                    claimType: staging.ClaimType,
                    claimSource: staging.ClaimSource,
                    createdByUserId: userId);

                // FR-D-2: Claims from tablet → set lifecycle to Submitted
                claim.Submit(userId, userId);

                await _unitOfWork.Claims.AddAsync(claim, ct);

                _idMap[staging.OriginalEntityId] = claim.Id;
                staging.SetCommittedEntityId(claim.Id);
                await _stagingClaimRepo.UpdateAsync(staging, ct);

                report.Claims.Committed++;
                report.Claims.IdMappings[staging.OriginalEntityId] = claim.Id;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to commit Claim {OriginalId}", staging.OriginalEntityId);
                report.Claims.Failed++;
                report.Errors.Add(new CommitErrorDto
                {
                    EntityType = "Claim",
                    StagingEntityId = staging.Id,
                    OriginalEntityId = staging.OriginalEntityId,
                    ErrorMessage = ex.Message
                });
            }
        }
    }

    /// <summary>
    /// Commit evidence to production with SHA-256 attachment deduplication (FR-D-9).
    /// Uses IEvidenceRepository.GetByFileHashAsync() for dedup lookup.
    /// </summary>
    private async Task CommitEvidenceAsync(
        Guid importPackageId, Guid userId, CommitReportDto report, CancellationToken ct)
    {
        var approved = await _stagingEvidenceRepo.GetApprovedForCommitAsync(importPackageId, ct);
        report.Evidences.EntityType = "Evidence";
        report.Evidences.Approved = approved.Count;

        if (approved.Count == 0) return;

        for (var i = 0; i < approved.Count; i++)
        {
            var staging = approved[i];
            try
            {
                // FR-D-9: Attachment deduplication by SHA-256 hash
                var filePath = staging.FilePath;
                if (!string.IsNullOrEmpty(staging.FileHash))
                {
                    // Check if evidence with this hash already exists in production
                    var existingEvidence = await _unitOfWork.Evidences
                        .GetByFileHashAsync(staging.FileHash, ct);

                    if (existingEvidence != null)
                    {
                        // Reuse existing file path — no need to store another copy
                        filePath = existingEvidence.FilePath;
                        report.DuplicateAttachmentsFound++;
                        report.DeduplicationBytesSaved += staging.FileSizeBytes;

                        _logger.LogInformation(
                            "Deduplicated evidence file {Hash} — reusing {ExistingPath}",
                            staging.FileHash, filePath);
                    }
                }

                var evidence = Evidence.Create(
                    evidenceType: staging.EvidenceType,
                    description: staging.Description,
                    originalFileName: staging.OriginalFileName,
                    filePath: filePath,
                    fileSizeBytes: staging.FileSizeBytes,
                    mimeType: staging.MimeType,
                    fileHash: staging.FileHash,
                    createdByUserId: userId);

                // Link to resolved production FKs
                if (staging.OriginalPersonId.HasValue &&
                    _idMap.TryGetValue(staging.OriginalPersonId.Value, out var prodPersonId))
                {
                    evidence.LinkToPerson(prodPersonId, userId);
                }

                if (staging.OriginalPersonPropertyRelationId.HasValue &&
                    _idMap.TryGetValue(staging.OriginalPersonPropertyRelationId.Value, out var prodRelId))
                {
                    evidence.LinkToRelation(prodRelId, userId);
                }

                if (staging.OriginalClaimId.HasValue &&
                    _idMap.TryGetValue(staging.OriginalClaimId.Value, out var prodClaimId))
                {
                    evidence.LinkToClaim(prodClaimId, userId);
                }

                await _unitOfWork.Evidences.AddAsync(evidence, ct);

                _idMap[staging.OriginalEntityId] = evidence.Id;
                staging.SetCommittedEntityId(evidence.Id);
                await _stagingEvidenceRepo.UpdateAsync(staging, ct);

                report.Evidences.Committed++;
                report.Evidences.IdMappings[staging.OriginalEntityId] = evidence.Id;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to commit Evidence {OriginalId}", staging.OriginalEntityId);
                report.Evidences.Failed++;
                report.Errors.Add(new CommitErrorDto
                {
                    EntityType = "Evidence",
                    StagingEntityId = staging.Id,
                    OriginalEntityId = staging.OriginalEntityId,
                    ErrorMessage = ex.Message
                });
            }
        }
    }
}
